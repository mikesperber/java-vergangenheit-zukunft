#+title: Hätte, hätte Fahrradkette
#+author: Falk Sippach, Mike Sperber
#+REVEAL_PLUGINS: (notes)
#+REVEAL_THEME: ./css/themes/active.css
#+REVEAL_HLEVEL: 1
#+REVEAL_TRANS: none
#+OPTIONS: toc:nil reveal-center:f H:4

* Falk Sippach

#+ATTR_HTML: :height 100px;
[[file:images/falk.jpg]]

Softwarearchitekt bei embarc

✉️falk.sippach@embarc.de

#+ATTR_HTML: :height 50px;
[[file:images/embarc.svg][file:images/embarc.svg]]

- Trainer für iSAQB Foundation und Advanced
- (Co-)Organisator von JUG Darmstadt, CyberLand, SpeaKonf, Tech2Talk
- JavaLand, Java Forum Nord, XP-Days, ...

* Mike Sperber

Active Group GmbH

=@sperbsen@discuss.systems=

#+ATTR_HTML: :height 100px;
[[file:images/ag-logo-plain.png][file:images/ag-logo-plain.png]]
- Tübingen, Germany
- Projektentwicklung, Beratung, Training
- Scala, Clojure, F#, Haskell, OCaml, Erlang, Elixir, Swift
- iSABQ Foundation, FUNAR, FLEX, DSL

Blog [[https://funktionale-programmierung.de]]

[[file:images/mike.jpg]]


* BOB 2025

[[file:images/bob_head_2to1.png]]

https://bobkonf.de/

* Warum sind wir hier? (F)
    :PROPERTIES:
    :reveal_background: ./images/fahrradkette.jpg
    :reveal_background_trans: slide
    :reveal_background_opacity: 0.2
    :END:

Java wird 30

#+ATTR_HTML: :class fragment
- Wie ist Java entstanden?
#+ATTR_HTML: :class fragment
- Was ist nicht gut gelöst in Java?
#+ATTR_HTML: :class fragment
- Wie entwickelt es sich gerade weiter?
#+ATTR_HTML: :class fragment
- Was fehlt in Java, was könnte noch kommen?

#+BEGIN_NOTES
https://pixabay.com/de/photos/fahrradkette-verrostet-alt-4788473/
#+END_NOTES

** Abstract

Java ist inzwischen 30 Jahre alt, und hat seit der Geburt viele Features dazubekommen.
Die meisten davon wurden nicht vom JDK-Team erfunden, sondern aus anderen Programmiersprachen und Forschungsarbeiten angepasst übernommen.

Durch die mittlerweile halbjährlichen Releases gibt es aktuell viel Bewegung im Java Ökosystem.
Und die nächste tolle Funktion gibt es höchstwahrscheinlich schon irgendwo da draußen.
Aber wisst Ihr eigentlich, woher die Features der Vergangenheit kommen?
Und können wir vielleicht jetzt schon vorhersehen, was die Zukunft bringen wird?

#+REVEAL: split

Im Vortrag werfen Falk (Java-Enthusiast) und Mike (Experte für Programmiersprachen) einen Blick in die Geschichte und in die Glaskugel:

- Was haben Generics, Lambdas, Streams und Virtual Threads gemeinsam?
- Warum nerven funktionale Programmierer:innen immer wegen der “tail calls”?
- Warum heißen Lambdas so und was fehlt, damit sie richtig toll werden?
- Was sind in Monaden und wo gibt’s die in Java?
- Ist Java mit Lambdas, Stream API und Pattern Matching schon eine funktionale Sprache?
- Ist Kotlin das Java der Zukunft?
- … und noch einiges mehr.


* Meilensteine von Java (F)

- 1995: 1.0
- 2004: 5.0 (Generics)
- 2014: 8 (Lambdas, Stream API, ...)
- 2017: 9 (JPMS, ...)
- 2018: 10 (halbjährliches Releases)
- 2021: 17 (Pattern Matching, ...)
- 2023: 21 (Virtual Threads, ...)

** Warum ist Java immer noch so populär? (F)

- halbjährliche Releases seit Java 10 (2018)
- LTS alle 2 Jahre
- Inkubator und Preview Features
- große Änderungen auf viele Releases verteilt

** Inspiriert durch ...

Algol60 -> Algol68 -> Pascal -> C -> Java

statische Typsysteme: HOPE und ML -> Miranda -> Haskell/OCaml/F#

#+BEGIN_NOTES
frühe OO-Sprachen waren ungetypt: Smalltalk, C++
#+END_NOTES

* Lambda (F)

#+begin_src java
Runnable r = () -> System.out.println("Hello from Lambda!");
new Thread(r).start();
#+end_src

#+BEGIN_NOTES
Warum keine Tail-Call-Optimierung?

Fehlende Unterstützung für Mehrzeiler.
#+END_NOTES

** Lambdas als Parameter (F)

Higher Order Functions:

#+begin_src java
List<String> names = List.of("Alice", "Bob", "Charlie");
List<String> upperCaseNames = names.stream()
    .map(name -> {
        System.out.println("Converting: " + name);
        return name.toUpperCase();
    })
    .toList();
System.out.println(upperCaseNames);  // [ALICE, BOB, CHARLIE]
#+end_src

Methodenreferenz:

#+begin_src java
List<String> names = List.of("Alice", "Bob", "Charlie");
names.forEach(System.out::println);
#+end_src


** McCarthy, 1960

#+ATTR_HTML: :class r-stretch
[[file:images/lisp.png]]

** LISP

[[file:images/lisp-lambda.png]]

** Church, 1941

[[file:images/church.png]]

** Lambda-Kalkül

[[file:images/church-lambda.png]]

** Warum hat das so lang gedauert?

**FP**
LISP (1960) ->
ML (1973) / Scheme (1975) / HOPE (1980)
Haskell/OCaml/F# (ab 1985)

**PROC**
Algol 60 ->
Pascal (1970) ->
C (1972)

**OOP**
Simula 67 ->
Smalltalk 80 ->
C++ (1985) ->
Java

** "Variable used in lambda expression should be final or effectively final"

#+begin_src java
private TimeZone extractCalendarTimeZoneComponent(Calendar cal, TimeZone calTz) {
    try {
        cal.getComponents().getComponents("VTIMEZONE")
          .forEach(component -> {
            VTimeZone v = (VTimeZone) component;
            v.getTimeZoneId();
            if (calTz == null) {
                calTz = TimeZone.getTimeZone(v.getTimeZoneId().getValue());
            }
        });
    } catch (Exception e) {
        log.warn("Unable to determine ical timezone", e);
    }
    return null;
}
#+end_src

** Was sind Closures?

[[file:images/landin-evaluation.png]]

** Landin, 1964

[[file:images/landin-closure.png]]

** Lambda für funktionale Interfaces (F)

#+begin_src java
Function<Integer, Integer> square = x -> x * x;
System.out.println(square.apply(5));  // 25
#+end_src


** Warum gibt es 51 Interfaces in =java.util.function=?

[[file:images/java-util-function.png]]

** Generics und primitive Typen

#+begin_src java

interface Function<T,R> {
    default <V> Function<T,V> andThen(Function<? super R,? extends V> after);
    R apply(T t)
    default <V> Function<V,R> compose(Function<? super V,? extends T> before)
    static <T> Function<T,T> identity()
}

interface DoubleFunction<R> {
    R apply(double value);
}
#+end_src

** Methoden als Objekte

#+begin_src java
int double(Function<Integer, Integer> f, int n) {
   return f.apply(f.apply(n));
}

static Integer inc(Integer n) {
    return n + 1;
}

... double(::inc, 7) ...
#+end_src

** Funktionstypen

"Cannot infer type"

#+begin_src java
var inc = (int x) -> x + 1;
#+end_src

** Funktionen in Haskell

#+begin_src haskell
(.) :: (b -> c) -> (a -> b) -> (b -> c)
f . g = \ a -> f (g a)

double :: (Integer -> Integer) -> Integer -> Integer
double f n = f (f n)

inc :: Integer -> Integer
inc n = n + 1

double inc 7
#+end_src

** Weitere Nahstellen

- =void=
- Statements vs. Ausdrücke
- =yield= vs. =return=

* Listen / Streams

#+begin_src java
#+end_src

#+begin_src java
#+end_src


#+BEGIN_NOTES
Falk: Lambdas wurden ja in Java 8 eingeführt, um die Programmierung
mit Streams zu unterstützen.  Kommen die Streams auch aus der
Lisp-Ecke?
#+END_NOTES

** Stream API

#+begin_src java
List<String> names = List.of("Alice", "Bob", "Charlie");
List<String> filtered = names.stream()
    .filter(name -> name.startsWith("A"))
    .collect(Collectors.toList());
System.out.println(filtered);  // [Alice]
#+end_src

#+BEGIN_NOTES
Performance und Debugging: Vorteil oder Frust?

Vergleich mit funktionalen Paradigmen.
#+END_NOTES

** LISP

[[file:images/lisp-1.png]]

** LISP

[[file:images/lisp-maplist.png]]

** List.of() (unmodifiable)

#+begin_src java
List<String> immutableList = List.of("A", "B", "C");
// immutableList.add("D");  // UnsupportedOperationException
#+end_src

#+BEGIN_NOTES
Warum keine echten Literals wie in Python oder Kotlin?
#+END_NOTES

*** ML/HOPE

FIXME

*** Eigenschaften

** sequenced collections

#+begin_src java
#+end_src

#+BEGIN_NOTES
#+END_NOTES

** stream gatherers

#+begin_src java
#+end_src

#+BEGIN_NOTES
#+END_NOTES

* Typen
** Generics

#+begin_src java
List<String> list = new ArrayList<>();
list.add("Hello");
// Compile-Time-Sicherheit
String value = list.get(0);  // Kein Cast nötig
#+end_src

#+BEGIN_NOTES
Warum gibt es keine Generics für primitive Typen?

Type Erasure: Einschränkung oder Vorteil?


#+END_NOTES

** Generics

[[file:images/gj.png]]

** Warum kein =ArrayList<int>=?

#+begin_src java
class LinkedList<A> {
    protected class Node {
        A elt;
        Node next = null;

        Node(A elt) {
            this.elt = elt;
        }
    }
    protected Node head = null, tail = null;
    ...
}
#+end_src

** Type Erasure

#+begin_src java
class LinkedList implements Collection {
    protected class Node {
        Object elt;
        Node next = null;

        Node (Object elt) {
            this.elt = elt;
        }
    }
    protected Node head = null, tail = null;
    ...
}
#+end_src

** Parametrische Polymorphie

[[file:images/strachey.png]]

** Strachey, 1967

[[file:images/parametric-polymorphism.png]]

** ML

[[file:images/milner.png]]

** Type Erasure blöd

** Parametricity

#+begin_src java
interface Stream<T> {
    <U> Stream<U> map(Function<T, U> f);
}
#+end_src

** Hätte, Hätte

"Cannot access class object of a type parameter"

#+begin_src java
public <T> T sum(ArrayList<T> list) {
if (T.class == Integer.class) {
    int result = 0;
    ...
    return new result;
} else if (T.class == Float.class) {
    float result = 0;
    ...
    return result;
}
#+end_src

** Fahrradkette

#+begin_src java
interface NumOps<T> {
    T zero();
    T plus(T t1, T t2);
    ...
}
    
class ArrayList<T> {
    T sum(automatic NumOps<T> ops) {
       T result = ops.zero();
       for (T element: this) {
          result = ops.plus(result, element);
       }
       return result;
    }
}
#+end_src

** Local variable type inference

#+begin_src java
ArrayList<Foo> list = new ArrayList<Foo>();
    ->
var list = Lists.of(new Foo());
#+end_src

#+BEGIN_NOTES
#+END_NOTES

** Damas/Milner 1982

[[file:images/damas-milner.png]]

** Warum hat das so lange gedauert?

#+begin_src java
interface Stream<R> {
  <R> Stream<R> map(Function<? super T,? extends R> mapper);
}
#+end_src

#+begin_src java
class A { }
class B extends A {}

...
    A[] as = new B[10];
    A a = as[0];
    as[0] = new A();
...
#+end_src

** Optional

#+BEGIN_NOTES
Mike: Übrigens, Falk, wo wir gerade bei ML sind, das hier kommt auch von da
#+END_NOTES

#+begin_src java
Optional<String> name = Optional.of("Alice");
name.ifPresent(System.out::println);  // Alice
#+end_src

#+BEGIN_NOTES
Optional<String> name = Optional.of("Alice");

name.ifPresent(System.out::println);  // Alice
#+END_NOTES

** Optional

Haskell

#+begin_src haskell
data Maybe a = Nothing | Just a
#+end_src

Standard ML

#+begin_src sml
datatype 'a option = NONE | SOME of 'a
#+end_src

OCaml

#+begin_src ocaml
type 'a t = 'a option = 
| None
| Some of 'a
#+end_src

(SML/NJ 1993)

** Nullable Types

#+begin_src java
#+end_src

#+BEGIN_NOTES
#+END_NOTES

** SQL, 1974

#+begin_src sql
CREATE TABLE orders
( order_id int NOT NULL,
  customer_id int,
  order_date date,
);
#+end_src

** Records

#+BEGIN_NOTES
Falk: Dann müßtest Du ja Records toll finden, das ist ja sowas wie
algebraische Datentypen in Haskell.
#+END_NOTES

#+begin_src java

#+end_src

** ALGOL W (1966)

[[file:images/algol-w.png]]

** ALGOL W

[[file:images/algol-w-record.png]]

** Alles über Daten und Typen, 1985

[[file:images/cardelli-wegner.png]]

** Functional Update

#+begin_src haskell
data Dillo = MkDillo { dilloLiveness :: Liveness,
                       dilloWeight :: Weight }

runOverDillo dillo = dillo { dilloLiveness = Dead }
#+end_src

** Sealed Classes

#+begin_src java
sealed interface Animal {
    record Dillo(Liveness liveness, Weight weight)
      implements Animal {}
    record Parrot(String sentence, Weight weight)
      implements Animal {}
}
#+end_src

#+BEGIN_NOTES
#+END_NOTES

** Haskell

#+begin_src haskell
data Animal =
    MkDillo { dilloLiveness :: Liveness, dilloWeight :: Weight }
  | MkParrot { parrotSentence:: String, parrotWeight :: Weight }
  deriving Show
#+end_src

** ISWIM

[[file:images/iswim.png]]

https://dl.acm.org/doi/10.1145/365230.365257

** ISWIM

[[file:images/iswim-adt.png]]

** CLU

[[file:images/clu.png]]

https://pmg.csail.mit.edu/ftp.lcs.mit.edu/pub/pclu/CLU/3.Documents/MIT-LCS-TR-225.pdf

** CLU (1979)

[[file:images/clu-oneof.png]]

** HOPE (1980)

[[file:images/hope.png]]

** HOPE

[[file:images/hope-data.png]]

** value types

#+begin_src java
#+end_src

#+BEGIN_NOTES
#+END_NOTES
* Pattern-Matching

** switch expressions

#+begin_src java
#+end_src

#+BEGIN_NOTES
#+END_NOTES

** LISP

FIXME

** Type Patterns

#+begin_src java
#+end_src

#+BEGIN_NOTES
#+END_NOTES

** CLU

[[file:images/clu-tagcase.png]]

** Pattern-Matching in switch

#+begin_src java
#+end_src

#+BEGIN_NOTES
#+END_NOTES

** LISP

[[file:images/lisp-mcbride.png]]

https://personal.cis.strath.ac.uk/conor.mcbride/FVMcB-PhD.pdf

** Hope

[[file:images/hope-pattern-matching.png]]

** record patterns

#+begin_src java
#+end_src

#+BEGIN_NOTES
#+END_NOTES

** unnamed patterns, variables

#+begin_src java
#+end_src

#+BEGIN_NOTES
#+END_NOTES

** primitive types in patterns

#+begin_src java
#+end_src

#+BEGIN_NOTES
#+END_NOTES

* Default Methods

#+begin_src java
interface Animal {
    default void eat() {
        System.out.println("Eating...");
    }
}
class Dog implements Animal {}
new Dog().eat();  // Eating...
#+end_src

#+BEGIN_NOTES
Flexibilität vs. Interface-Verschmutzung.

Hätte man Mixins einführen sollen?
#+END_NOTES

** Sather

FIXME

* Was gab's noch

- Modulsystem
- virtuelle Threads
- /structured concurrency/
- /scoped values/
- /string templates/
- /statements before super/
- /implicitly declared classes/, /instance main methods/
- /flexible constructor bodies/

** Entwicklungslinien

**FP**
LISP (1960) ->
ML (1973) / Scheme (1975) / HOPE (1980)
Haskell/OCaml/F# (ab 1985)

**PROC**
Algol 60 ->
Pascal (1970) ->
C (1972) ->
Java (1995)

**OOP**
Simula 67 ->
Smalltalk 80 ->
C++ (1985) ->
Java

** Zuordnung

| Generics               | ML         | FP      |
| Lambda                 | LISP       | FP      |
| Listen/map             | LISP       | FP      |
| Typinferenz            | ML         | FP      |
| Records                | ALGOL W/ML | PROC/FP |
| Virtual Threads        | Scheme     | FP      |
| Structured Concurrency | Erlang     | FP      |
| Scoped Values          | LISP       | FP      |
| Modulsystem            | (ML)       | (FP)    |

** Was kommt noch?

- Value types
- Generics over Primitive Types
- Nullable Types

* Was hat Haskell, was ich nicht habe?

** Funktionstypen

#+begin_src haskell
map :: (a -> b) -> [a] -> [b]
#+end_src

** Uniforme Generics

#+begin_src haskell
map (+1) [1,2,3,4,5,6]
#+end_src

** Tupel

#+begin_src haskell
div_mod :: Integer -> Integer -> (Integer, Integer)
div_mod a b = (a `div` b, a `mod b`)
#+end_src

** Either

#+begin_src haskell
data Either a b
  = Left a
  | Right b 

data ParseDigitError
  = NotADigit Char
  deriving Show

parseDigit :: Char -> Either ParseDigitError Int
parseDigit c =
  case c of
    '0' -> Right 0
    '1' -> Right 1
    '2' -> Right 2
    '3' -> Right 3
    '4' -> Right 4
    '5' -> Right 5
    '6' -> Right 6
    '7' -> Right 7
    '8' -> Right 8
    '9' -> Right 9
    _ -> Left (NotADigit c)
#+end_src

** Tail Calls

#+begin_src haskell
rev [] acc = acc
rec (x:xs) acc = rev xs (x:acc)
#+end_src

** Typklassen/Implicits

#+begin_src haskell
class Semigroup a where
  -- combine (combine x y) z == combine x (combine y z)
  combine :: a -> a -> a

class Semigroup a => Monoid a where
  -- combine neutral x == combine x neutral == x
  neutral :: a

foldMonoid :: Monoid b => [b] -> b
foldMonoid list = foldr combine neutral list
#+end_src

* Vielen Dank

Fragen
